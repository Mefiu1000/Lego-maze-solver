#pragma config(Sensor, S1,     L1,                  sensorSONAR)
#pragma config(Sensor, S2,     L2,                  sensorSONAR)
#pragma config(Sensor, S3,     L3,                  sensorSONAR)
#pragma config(Sensor, S4,     L4,                  sensorNone)
#pragma config(Motor,  motorA,          motorLeft,     tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          motorRight,    tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define TILE 0.3 //tile length
#define AXLE 0.145 // 137 mm measured
#define WHEEL 0.0205
#define SPEED 20

//Walls values according to global direction (NORTH is not always forward etc.)
#define  WEST    1    //  00000001
#define  SOUTH   2    //  00000010
#define  EAST    4    //  00000100
#define  NORTH   8    //  00001000

#define ROWS 6
#define COLUMNS 6
#define MAZE_SIZE ROWS * COLUMNS //6x6
#define VISITED 64
#define MODE 3 // 2- search, 3 - speeedrun
//Sets correct target for used mode
#if MODE == 3
  #define TARGET_CELL 21
#elif MODE == 2
  #define TARGET_CELL 1
#endif


              /* START Move related functions */

void move_1_tile(float dist,float left_wall, float right_wall); //and speed correction
void turn(float angle);

              /* END Move related functions */

              /* START Map updating functions */

void add_wall(byte position, byte orientation, byte Wall);
void init_map();
void init_dist(byte target);

              /* END Map updating functions */

              /* START Algorythm related functions */

byte change_orientation(byte orientation, char action);
byte change_position(byte position, byte orientation);
void floodfill(byte current_position);
byte where_to_move(byte current_position, byte orientation);
byte change_target(byte position, byte target);

              /* END Algorythm related functions */
void print_array(byte action);
//void display_distances(int dL, int dF, int dR, int dB);

//global variables
enum {dirLeft=0, dirForward=1, dirRight=2, dirBackward=3};
short const tresholdLeft = 24, tresholdForward = 20, tresholdRight = 24;//, tresholdBack = 1000;

byte map[MAZE_SIZE] =
  {0,0,0,0,0,0,
  0,0,0,0,0,0,
  0,0,0,0,0,0,
  0,0,0,0,0,0,
  0,0,0,0,0,0,
  0,0,0,0,0,0};

byte distance[MAZE_SIZE];

task speed_regulation()
{
   float P, I, D, MotorSpeed, error, error_derivative;
   float previous_error = 0;
   float error_integral = 0;
	 P = 0.08;
	 I = 0.002; //0.002 0.00174
	 D = 0; //0.00011
	 float Middle = 11.5;
  for(byte cycle = 0; cycle < 20; cycle++)
  {
   short sens_distance[4] = {0,0,0,0};
	 byte cL = 0;
	 byte cR = 0;
	 short avgL = 0;
	 short avgR = 0;;
	 for(short i = 0; i < 20; i++)
	 {
	    sens_distance[dirLeft] = SensorValue[L1];
	    wait1Msec(5);
	    sens_distance[dirRight] = SensorValue[L3];
	    wait1Msec(5);
	    bool lw = sens_distance[dirLeft] < tresholdLeft;
	    bool rw = sens_distance[dirRight] < tresholdRight;
	    if(lw)
	    {
	      cL++;
	      avgL += sens_distance[dirLeft];
	    }
	    if(rw)
	    {
	      cR++;
	      avgR += sens_distance[dirRight];
	    }
	 }
	 //average score of sensors measurement
	 if(cL > 1) avgL = avgL / cL;
	 if(cR > 1) avgR = avgR / cR;
	 bool left_wall = (cL >= 13);
	 bool right_wall = (cR >= 13);
	 if(left_wall && right_wall)
	 {
	    error = avgR - avgL;
			error_integral += error;
			error_derivative = (previous_error - error);
			previous_error = error;
			MotorSpeed = P * error + I * error_integral + D * error_derivative;
			motor[motorLeft] = SPEED + MotorSpeed;
      motor[motorRight] = SPEED - MotorSpeed;
	 }
	 else if(left_wall)
	 {
	    error = Middle - avgL;
			error_integral += error;
			error_derivative = (previous_error - error);
			previous_error = error;
			MotorSpeed = P * error + I * error_integral + D * error_derivative;

			motor[motorLeft] = SPEED + MotorSpeed;
      motor[motorRight] = SPEED - MotorSpeed;
	 }
	 else if(right_wall)
	 {
	    error = Middle - avgR;
			error_integral += error;
			error_derivative = (previous_error - error);
			previous_error = error;
			MotorSpeed = P * error + I * error_integral + D * error_derivative;
			motor[motorLeft] = SPEED - MotorSpeed;
      motor[motorRight] = SPEED + MotorSpeed;
	 }
	 //writeDebugStreamLine("%d",time1(T1));
 }
 StopTask(speed_regulation);
}

task main()
{

  byte position = 0;
  byte direction = 8; //where robot wants to move
  byte target = TARGET_CELL;
  byte mode = MODE; //2- search, 3 - speeedrun
  byte open = 1; //to open file 1 time
  init_map();

  byte orientation = NORTH; //orientation of the robot

  short sens_distance[4] = {0,0,0,0};
  //eraseDisplay();
  //nSyncedMotors= synchAC;

  while(1)
  {
	   byte cL = 0;
	   byte cR = 0;
	   byte cF = 0;
	   short avgL = 0;
	   short avgR = 0;
	   short avgF = 0;

	   for(short i = 0; i < 20; i++)
	   {
		    sens_distance[dirLeft] = SensorValue[L1];
		    wait1Msec(8);
		    sens_distance[dirForward] = SensorValue[L2];
		    wait1Msec(8);
		    sens_distance[dirRight] = SensorValue[L3];
		    wait1Msec(8);

		    bool lw = sens_distance[dirLeft] < tresholdLeft;
	      bool fw = sens_distance[dirForward] < tresholdForward;
	      bool rw = sens_distance[dirRight] < tresholdRight;

	      if(lw)
	      {
	        cL++;
	        avgL += sens_distance[dirLeft];
	      }
	      if(fw)
	      {
	      	cF++;
	        avgF += sens_distance[dirForward];
	      }
	      if(rw)
	      {
	        cR++;
	        avgR += sens_distance[dirRight];
	      }
	   }
	   //average score of sensors measurement
	   if(cL > 1) avgL = avgL / cL;
		 if(cR > 1) avgR = avgR / cR;
		 if(cF > 1) avgF = avgF / cF;

	   bool left_wall = (cL >= 13);
	   bool front_wall = (cF >= 13);
	   bool right_wall = (cR >= 13);

	   /* START Wall detection */

	   if(left_wall)  add_wall(position, orientation, WEST);
		 if(front_wall) add_wall(position, orientation, NORTH);
		 if(right_wall) add_wall(position, orientation, EAST);
		 /* END Wall detection */

     print_array(1); ////print map with explored walls
     wait1Msec(1000);

	   if(mode == 2)
	   {
			              /* START floodfill search run */

			  init_dist(target); //reset path
			  floodfill(0); //path
			  print_array(0); //print current path and distance
			  direction = where_to_move(position, orientation);

			  if(orientation == direction) //forward
			  {
			    if(left_wall && right_wall) move_1_tile(TILE, avgL, avgR); //speed correction only when 2 walls are detected
			    else if(left_wall) move_1_tile(TILE, avgL, 30.0 - (float)avgL - 11.4);
			    else if(right_wall) move_1_tile(TILE, 30.0 - (float)avgR - 11.4, avgR);
			    else move_1_tile(TILE,0, 0); // two 0 to avoid speed correction
			  }
			  else if( !((orientation == WEST) && (direction == NORTH)) != !( (orientation / 2) == direction) ) //right, XOR, '!' to avoid nonzero values
			  {
			    orientation = change_orientation(orientation, 'D');
			    turn(PI/2);
			    wait1Msec(300);
			    move_1_tile(TILE,0, 0); // two 0 to avoid speed correction
			  }
			  else if( !((orientation == NORTH) && (direction == WEST)) != !( (orientation * 2) == direction) ) //left, XOR
			  {
			    orientation = change_orientation(orientation, 'A');
			    turn(-PI/2);
			    wait1Msec(300);
			    move_1_tile(TILE,0, 0); // two 0 to avoid speed correction
			  }
			  else if( !( (orientation * 4) == direction) != !( (orientation / 4) == direction) ) //back, XOR
			  {
			    orientation = change_orientation(orientation, 'S');
			    if(avgR < avgL) turn(PI);
			    else turn(-PI);
			    wait1Msec(300);
			    move_1_tile(TILE,0, 0); // two 0 to avoid speed correction
			  }

			  position = change_position(position, orientation);
			  map[position] = map[position] | VISITED; //mark visited tile

			  if(position == target)
			  {
			    target = change_target(position, target);
			  }

		              /* END floodfill search run */
	   }
	   else if(mode == 3)
     {
	              /* START floodfill fast run */
	     if(open)
	     {
	       PlaySound(soundBeepBeep);
		     TFileIOResult Result;
		     TFileHandle MazeHandle;
		     short FileSize = MAZE_SIZE;
		     string FileNamePath = "Maze_path.dat";
				 string FileNameMaze = "Maze_config.dat";
		       //writeDebugStreamLine("jest plik NXT");
		       OpenRead(MazeHandle, Result, FileNamePath, FileSize);
		       for(byte i = 0; i < 36; i++)
		       {
		         ReadByte(MazeHandle,Result,distance[i]);
		       }

				 Close(MazeHandle,Result);
				 wait1Msec(10);
			   print_array(0);//print distance map

			   OpenRead(MazeHandle, Result, FileNameMaze, FileSize);
		       for(byte i = 0; i < 36; i++)
		       {
		         ReadByte(MazeHandle,Result,map[i]);
		       }
				 Close(MazeHandle,Result);

				 print_array(2); //print map without visited mark

				 init_dist(target); //reset path
	       floodfill(0); //path
			   open = 0;
			 }
			print_array(0); //print current path and distance
	    direction = where_to_move(position, orientation);

	    if(orientation == direction) //forward
			  {
			    if(left_wall && right_wall) move_1_tile(TILE, avgL, avgR); //speed correction only when 2 walls are detected
			    else if(left_wall) move_1_tile(TILE, avgL, 30.0 - (float)avgL - 11.4);
			    else if(right_wall) move_1_tile(TILE, 30.0 - (float)avgR - 11.4, avgR);
			    else move_1_tile(TILE,0, 0); // two 0 to avoid speed correction
			  }
			  else if( !((orientation == WEST) && (direction == NORTH)) != !( (orientation / 2) == direction) ) //right, XOR, '!' to avoid nonzero values
			  {
			    orientation = change_orientation(orientation, 'D');
			    turn(PI/2);
			    wait1Msec(300);
			    move_1_tile(TILE,0, 0); // two 0 to avoid speed correction
			  }
			  else if( !((orientation == NORTH) && (direction == WEST)) != !( (orientation * 2) == direction) ) //left, XOR
			  {
			    orientation = change_orientation(orientation, 'A');
			    turn(-PI/2);
			    wait1Msec(300);
			    move_1_tile(TILE,0, 0); // two 0 to avoid speed correction
			  }
			  else if( !( (orientation * 4) == direction) != !( (orientation / 4) == direction) ) //back, XOR
			  {
			    orientation = change_orientation(orientation, 'S');
			    if(avgR < avgL)turn(PI);
			    else turn(-PI);
			    wait1Msec(300);
			    move_1_tile(TILE,0, 0); // two 0 to avoid speed correction
			  }

		  position = change_position(position, orientation);
		  map[position] = map[position] | VISITED; //mark visited tile

		  if(position == target)
		  {
		    PlaySound(soundBeepBeep);
		    StopTask(main);
		  }
	              /* END floodfill fast run */
    }
  }
}























                                /* FUNCTIONS */
      /****************************************************************/
      /****************************************************************/
      /****************************************************************/

                      /* START Move related functions */

// makes robot to move 1 tile
void move_1_tile(float dist,float left_wall, float right_wall)
{

  float L_speed = SPEED;
  float R_speed = SPEED;
  float R_dist = 1;
  float L_dist = 1;

  float  rev_m, rev_p;

  //move 1 tile or cert dist
  rev_m = dist/WHEEL; //how many rev in radians
  rev_p = rev_m *360/2/PI; //how many rev in pulses
  nSyncedTurnRatio = 100;
  nMotorEncoder[motorLeft] = 0; //zeroing encoder value
  nMotorEncoder[motorRight] = 0; //zeroing encoder value
  nMotorEncoderTarget[motorLeft] = rev_p * L_dist; //set encoder target
  nMotorEncoderTarget[motorRight] = rev_p * R_dist; //set encoder target

  if(dist > 0) //move forward
  {
    motor[motorLeft] = L_speed;
    motor[motorRight] = R_speed;
  }
  else //move backward
  {
    motor[motorLeft] = -L_speed;
    motor[motorRight] = -R_speed;
  }

  //ClearTimer(T1);
  StartTask(speed_regulation);
  while( (nMotorEncoder[motorLeft] < rev_p) && (nMotorEncoder[motorRight] < rev_p) )  // While Motors are still running (hasn't reached target yet)
  {
    if(nMotorRunState[motorLeft] != runStateRunning) break;
    else if(nMotorRunState[motorRight] != runStateRunning) break;
   //writeDebugStreamLine("%d",time1(T1));
  }

  motor[motorLeft] = 0;                       // Motor l is stopped at a power level of 0.
  motor[motorRight] = 0;                       // Motor r is stopped at a power level of 0.
}

void turn(float angle)
{
  float  rev_m, rev_p;

  rev_m = angle * AXLE/2/WHEEL; //how many rev in radians
  rev_p = rev_m *360/2/PI; //how many rev in pulses
  nSyncedTurnRatio = -100;
  nMotorEncoder[motorLeft] = 0;
  nMotorEncoder[motorRight] = 0;
  nMotorEncoderTarget[motorLeft] = rev_p;
  nMotorEncoderTarget[motorRight] = -rev_p;
  if(angle >0)
  {
    motor[motorLeft] = SPEED;
    motor[motorRight] = -SPEED;
  }
  else
  {
    motor[motorLeft] = -SPEED;
    motor[motorRight] = SPEED;
  }

  ClearTimer(T1);
  while((nMotorRunState[motorLeft] == runStateRunning) && (nMotorRunState[motorRight] == runStateRunning))  // While Motors are still running (hasn't reached target yet)
  {
    if(time1(T1) > 4000) break; //to avoid motors problem with idle state
  }
  motor[motorLeft] = 0;                       // Motor l is stopped at a power level of 0.
  motor[motorRight] = 0;                       // Motor r is stopped at a power level of 0.
}

                    /* END Move related functions */


                    /* START Map updating functions */

//add wall according to distance sensors
void add_wall(byte position, byte orientation, byte Wall)
{

  if(orientation == EAST)
  {
    if(Wall != WEST) Wall /= 2;
    else Wall = 8;
  }
  else if(orientation == SOUTH)
  {
    if( (Wall == WEST) || (Wall == SOUTH) ) Wall *= 4;
    else Wall /= 4;
  }
  else if(orientation == WEST)
  {
    if(Wall != NORTH) Wall *= 2;
    else Wall = 1;
  }

  map[position] = map[position] | Wall; //adds sensed wall

  if( Wall == NORTH )
  {
    if((position + COLUMNS) < 36)
    {
      position = position + COLUMNS;          //upper field
      map[position] = map[position] | SOUTH;
    }
  }
  if( Wall == EAST )
  {
    if((position + 1) < 36)
    {
      position = position + 1;
      map[position] = map[position] | WEST; //field on the left
    }
  }
  if( Wall == SOUTH )
  {
    if((position - COLUMNS) >= 0)
    {
	    position = position - COLUMNS;
	    map[position] = map[position] | NORTH;  //lower field
    }
  }
  if( Wall == WEST )
  {
    if((position - 1) >= 0)
    {
	    position = position - 1;
	    map[position] = map[position] | EAST; //field on the right
	  }
  }
}

//init maze map with external walls
void init_map()
{
  map[0] = map[0] | VISITED; //mark start as visited

  for(byte i = 0; i < 6 ;i++)
  {
    map[i] = map[i] | SOUTH;
  }
  for(byte i = 30; i < 36 ;i++)
  {
   map[i] = map[i] | NORTH;
  }
  for(byte i = 0; i <= 30 ;i+=6)
  {
   map[i] = map[i] | WEST;
  }
  for(byte i = 5; i < 36 ;i+=6)
  {
   map[i] = map[i] | EAST;
  }

  //print_array(map, 0);
}

//init distance map with 127 and 0 as target (needed for floodfill algorythm)
void init_dist(byte target)
{
  for(short i = 0; i < MAZE_SIZE; i++)
  {
    distance[i] = 127;
  }
  distance[target] = 0;
}

                    /* END Map updating functions */

                    /* START Algorythm related functions */

//change robot orientation basing on last orientation and last turn
byte change_orientation(byte orientation, char action)
{
  switch(action)
  {
    case 'D': //turning right
    if(orientation == WEST) orientation = NORTH;
    else orientation = orientation / 2;
    break;
    case 'A': //turning left
    if(orientation == NORTH) orientation = WEST;
    else orientation = orientation * 2;
    break;
    case 'S': //turning back
    if((orientation == NORTH) || (orientation == EAST)) orientation = orientation / 4;
    else orientation = orientation * 4;
    break;
  }
  return orientation;
}

//update position of the robot basing on current orientation of the robot
byte change_position(byte position, byte orientation)
{
  if( orientation == NORTH )
  {
    position = position + COLUMNS;
  }
  if( orientation == EAST )
  {
    position = position + 1;
  }
  if( orientation == SOUTH )
  {
    position = position - COLUMNS;
  }
  if( orientation == WEST )
  {
    position = position - 1;
  }


   return position;
}

//floodfill algorythm
void floodfill(byte current_position)
{
bool search = true;
while(search)
{
  search = false;
  for(short i = 0; i < MAZE_SIZE; i++)
  {
    if(distance[i] < 127)
    {
      if((map[i] & NORTH) != NORTH)
      {
        if(distance[i + COLUMNS] == 127 || ((distance[i] + 1) < distance[i + COLUMNS]) )
        {
          distance[i + COLUMNS] = distance[i] + 1; //NORTH
          search = true;
        }
      }
      if((map[i] & EAST) != EAST)
      {
        if(distance[i + 1] == 127  || ((distance[i] + 1) < distance[i + 1]))
        {
          distance[i + 1] = distance[i] + 1; //EAST
          search = true;
        }
      }
      if((map[i] & SOUTH) != SOUTH)
      {
        if(distance[i - COLUMNS] == 127 || ((distance[i] + 1) < distance[i - COLUMNS]))
        {
          distance[i - COLUMNS] = distance[i] + 1; //SOUTH
          search = true;
        }
      }
      if((map[i] & WEST) != WEST)
      {
        if(distance[i - 1] == 127 || ((distance[i] + 1) < distance[i - 1]))
        {
          distance[i - 1] = distance[i] + 1; //WEST
          search = true;
        }
      }
    }
  }
}
}

//decide where to move by checking distance values in neighbors cells
byte where_to_move(byte current_position, byte orientation)
{
  byte best_neighbor = 127;
  byte direction = NORTH;

      if((map[current_position] & NORTH) != NORTH)
      {
        if((current_position + COLUMNS) < 36) //prop not necess, upper condition makes it impossible if walls are correctly found
        {
	        if(distance[current_position + COLUMNS] <= best_neighbor)
	        {
	          if(distance[current_position + COLUMNS] < best_neighbor)
	          {
	            best_neighbor = distance[current_position + COLUMNS];
	            direction = NORTH;
	          }
	          else if(orientation == NORTH) direction = NORTH;
	        }
        }
      }
      if((map[current_position] & EAST) != EAST)
      {
        if((current_position + 1) < 36) //prop not necess, upper condition makes it impossible if walls are correctly found
        {
	        if(distance[current_position + 1] <= best_neighbor)
	        {
	          if(distance[current_position + 1] < best_neighbor)
	          {
	            best_neighbor = distance[current_position + 1];
	            direction = EAST;
	          }
	          else if(orientation == EAST) direction = EAST;
	        }
        }
      }
      if((map[current_position] & SOUTH) != SOUTH)
      {
        if((current_position - COLUMNS) >= 0) //prop not necess, upper condition makes it impossible if walls are correctly found
        {
	        if(distance[current_position - COLUMNS] <= best_neighbor)
	        {
		        if(distance[current_position - COLUMNS] < best_neighbor)
		        {
		          best_neighbor = distance[current_position - COLUMNS];
		          direction = SOUTH;
		        }
		        else if(orientation == SOUTH) direction = SOUTH;
          }
        }
      }
      if((map[current_position] & WEST) != WEST)
      {
        if((current_position - 1) >= 0) //prop not necess, upper condition makes it impossible if walls are correctly found
        {
	        if(distance[current_position - 1] <= best_neighbor)
	        {
	          if(distance[current_position - 1] < best_neighbor)
	          {
	            best_neighbor = distance[current_position - 1];
	            direction = WEST;
	          }
	          else if(orientation == WEST) direction = WEST;
	        }
	      }
      }

      return direction;
}

//marks every visited cell, after reaching targeted cell, change cell to first unvisited cell
//when reaching final target, saves distance map to file
byte change_target(byte position, byte target)
{
     bool search = true;
     byte i = 0;

     while(search) //search to find unvisited cell, otherwise end
     {
       if( !(map[i] & VISITED) )
       {
         target = i;
         search = false;
         //printf("target = %d\n",target);
       }
       else i++;
       if(i == 36) //if all cells visited, go to final target
       {
         /*
         //printf("target = %d\n",target);
         search = false;
         i = 0; */
         target = 21;
         floodfill(0); //path
       PlaySound(soundBeepBeep);
       print_array(1); //print final map
       print_array(0); //print final path
		   TFileIOResult Result, Result_delete;
		   TFileHandle MazeHandle;
		   short FileSize = MAZE_SIZE;
		   string FileNamePath = "Maze_path.dat";
		   string FileNameMaze = "Maze_config.dat";
		   Delete(FileNamePath,Result_delete);
		   //if(Result_delete == 0) writeDebugStreamLine("usunieto plik ");
		   //else if (Result_delete != 0) writeDebugStreamLine("blad ");
		   //writeDebugStreamLine("brak pliku,robie ");
		   OpenWrite(MazeHandle, Result, FileNamePath, FileSize);
		   for(byte i = 0; i < 36; i++)
		   {
		    WriteByte(MazeHandle,Result,distance[i]); //write distance map
		   }
       Close(MazeHandle,Result);

       wait1Msec(10); //just to make sure handler is free

       Delete(FileNameMaze,Result_delete);
       OpenWrite(MazeHandle, Result, FileNameMaze, FileSize);
		   for(byte i = 0; i < 36; i++)
		   {
		    WriteByte(MazeHandle,Result,map[i]); //write map config
		   }
       Close(MazeHandle,Result);
       wait1Msec(1000);
       StopTask(main);
       }
     }
     /*
     if((position == target) && (i == 0) && (target == 21)) //after reaching final target, save result in file
     {
       PlaySound(soundBeepBeep);
       print_array(1); //print final map
       print_array(0); //print final path
		   TFileIOResult Result, Result_delete;
		   TFileHandle MazeHandle;
		   short FileSize = MAZE_SIZE;
		   string FileNamePath = "Maze_path.dat";
		   string FileNameMaze = "Maze_config.dat";
		   Delete(FileNamePath,Result_delete);
		   //if(Result_delete == 0) writeDebugStreamLine("usunieto plik ");
		   //else if (Result_delete != 0) writeDebugStreamLine("blad ");
		   //writeDebugStreamLine("brak pliku,robie ");
		   OpenWrite(MazeHandle, Result, FileNamePath, FileSize);
		   for(byte i = 0; i < 36; i++)
		   {
		    WriteByte(MazeHandle,Result,distance[i]); //write distance map
		   }
       Close(MazeHandle,Result);

       wait1Msec(10); //just to make sure handler is free

       Delete(FileNameMaze,Result_delete);
       OpenWrite(MazeHandle, Result, FileNameMaze, FileSize);
		   for(byte i = 0; i < 36; i++)
		   {
		    WriteByte(MazeHandle,Result,map[i]); //write map config
		   }
       Close(MazeHandle,Result);
       wait1Msec(1000);
       StopTask(main);
     }
     */

   return target;
}

                    /* END Algorythm related functions */
void print_array(byte action)
{
  if(action == 0) //print distance
  {
    writeDebugStream("DISTANCE");
    writeDebugStreamLine("");
    for(byte i = 30, k = 1; i >= 0; i++)
     {
       writeDebugStream("%3d ",distance[i]);
       if(k == 6)
       {
         writeDebugStreamLine("");
         i-=12;
         k = 1;
       }
       else k++;
     }
     writeDebugStreamLine("DISTANCE");
   }
   else if(action == 1) //print map
   {
    writeDebugStream("MAP");
    writeDebugStreamLine("");
    for(byte i = 30, k = 1; i >= 0; i++)
     {
       writeDebugStream("%3d ",map[i]);
       if(k == 6)
       {
         writeDebugStreamLine("");
         i-=12;
         k = 1;
       }
       else k++;
     }
     writeDebugStreamLine("MAP");
   }
   else //print map without visited mark (only walls)
   {
     byte array[MAZE_SIZE];

     for(byte i = 0; i <= 35; i++)
     {
       array[i] = map[i];
       //array[i] -= 64;
       if(array[i] & VISITED) array[i] -= 64;//version to avoid negative values(errors etc.)
     }
	   writeDebugStream("MAP");
	   writeDebugStreamLine("");
	   for(byte i = 30, k = 1; i >= 0; i++)
	   {
	     writeDebugStream("%3d ",map[i]);
	     if(k == 6)
	     {
	       writeDebugStreamLine("");
	       i-=12;
	       k = 1;
	     }
	     else k++;
	   }
	   writeDebugStreamLine("MAP");
	 }
}






/*
void display_distances(int dL, int dF, int dR, int dB)
{
   nxtDisplayCenteredTextLine(1, "F=%d", dF);
   nxtDisplayCenteredTextLine(2, "L=%d       R=%d", dL, dR);
   nxtDisplayCenteredTextLine(3, "B=%d", dB);
}*/
